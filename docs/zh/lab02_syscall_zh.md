中文 | [English](./../en/lab02_syscall.md)

> [!IMPORTANT]  
> 以下文章可能会对您的解决有决定性的帮助。如果您希望自己独立解决，**请勿**查看。如果您觉得有帮助，请考虑 Star 这个仓库！

## add trace syscall

没什么值得记录的。`ecall`：执行一些操作，然后跳转到 `trap.c`，在那里调用 `syscall`。

## attack xv6

`my secret secret ..` 中的前几个字节在 `secret` 退出后被修改了。为什么？使用 GDB 来找出原因。方法如下：

* 不能直接在 `secret.c` 中在目标地址上设置 breakpoint，因为此时还在用户模式，设置的不是正确的地址。
* 所以我们需要在内核态中知道它的地址，有什么方法？可以通过定义一个系统调用来曲线结果（比如我是临时修改上一个问题中的 `trace`）。修改 `secret.c`，将对应的变量（即 `secret`）作为参数传递给这个系统调用。
* 然后就可以在系统调用的开始处设置断点。现在内核模式中，就可以访问从用户模式传递的地址。
* 但是，我们仍然**不能**在这个地址上设置监视点。因为它是用户进程空间中的虚拟地址（例如，`0xd000`）。
* 要继续，在系统调用内部检索**物理地址**。怎么做？询问 LLM，你会得到正确答案：

  ```c
  uint64 pa = walkaddr(myproc()->pagetable, va);
  ```
* 现在你可以在**物理**地址（即 `pa`）上设置监视点。
* 你会发现内容被改变了，因为前几个字节被用来存储指向空闲内存列表中**下一个**页面的指针。

这是代码的相关部分：

```c
// freeproc --> ... --> kfree
// pa 是每个页面的地址
void kfree(void *pa) {
  // ...

  struct run *r;
  r = (struct run*)pa;
  // 修改前几个字节...
  r->next = kmem.freelist;
  kmem.freelist = r;
  // ...
}
``` 